-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/tbidne/crypto#readme</a>
@package crypto
@version 0.1.0.0

module Common
padToN :: Int -> [Word8] -> (Word8, [Word8])
intToWord8List :: Integer -> [Word8] -> [Word8]
word8ListToInt :: [Word8] -> Integer
xorByte :: Bits a => [a] -> a -> [a]
xorList :: Bits a => [a] -> [a] -> [a]
xorMatrix :: Bits a => [[a]] -> [[a]] -> [[a]]
flatListToMatrix :: Int -> [a] -> [[a]] -> [[a]]
byteStringToInt :: ByteString -> (Integer, ByteString)
intToByteString :: Integer -> ByteString

module AES.API

-- | Takes an <a>Int</a> <tt>size</tt> and a <a>String</a>
--   <tt>filename</tt>. Generates a key based on <a>keygen</a> and writes
--   the key to the file.
keygenIO :: Int -> String -> IO ()

-- | Takes 3 <a>String</a>s, <tt>keyFile</tt>, <tt>fileIn</tt>,
--   <tt>fileOut</tt>. <tt>fileIn</tt> is encrypted based on <a>encrypt</a>
--   with <tt>keyFile</tt>, and the ciphertext is written to
--   <tt>fileOut</tt>.
encryptIO :: String -> String -> String -> IO ()

-- | Takes 3 <a>String</a>s, <tt>keyFile</tt>, <tt>fileIn</tt>,
--   <tt>fileOut</tt>. <tt>fileIn</tt> is decrypted based on <a>decrypt</a>
--   with <tt>keyFile</tt>, and the decrypted text is written to
--   <tt>fileOut</tt>.
decryptIO :: String -> String -> String -> IO ()

-- | Takes a <a>RandomGen</a> <tt>g</tt>, <a>Int</a> <tt>size</tt>. If
--   <tt>size</tt> is one of 128, 192, or 256 then generates a number
--   <tt>n</tt> in <tt>[2^(size-1), 2^size - 1]</tt> and returns
--   <a>Just</a> <a>ByteString</a> based on <tt>n</tt>. Otherwise returns
--   <a>Nothing</a>.
keygen :: (RandomGen a) => a -> Int -> Maybe ByteString

-- | Takes in two <tt>ByteStrings</tt>, <tt>k</tt>, <tt>m</tt> representing
--   the <tt>key</tt> and <tt>message</tt> to be encrypted. Returns the
--   encrypted <a>ByteString</a>.
encrypt :: ByteString -> ByteString -> ByteString

-- | Takes in two <tt>ByteStrings</tt>, <tt>k</tt>, <tt>c</tt> representing
--   the <tt>key</tt> and <tt>ciphertext</tt> to be dcecrypted. Returns the
--   decrypted <a>ByteString</a>.
decrypt :: ByteString -> ByteString -> ByteString

module NumberTheory
genPrime :: (RandomGen a, Integral b) => a -> b -> Integer
powModN :: Integral a => a -> a -> a -> a
findInverse :: (Integral a) => a -> a -> a -> a

module RSA.Internal
data Key
Key :: !Integer -> !Integer -> Key
[keyModulus] :: Key -> !Integer
[keyExponent] :: Key -> !Integer
keyToByteString :: Key -> ByteString
byteStringToKey :: ByteString -> Key
genModulus :: (RandomGen a, Integral b) => a -> b -> (Integer, Integer)
instance GHC.Show.Show RSA.Internal.Key
instance GHC.Classes.Eq RSA.Internal.Key

module RSA.API

-- | Takes an <a>Integral</a> <tt>size</tt> and two strings
--   <tt>pubFileOut</tt>, <tt>prvFileOut</tt>. Generates a public/private
--   key pair based on <a>keygen</a> and writes the key pair to the files.
keygenIO :: Integral a => a -> String -> String -> IO ()

-- | Takes 3 <a>String</a>s, <tt>keyFile</tt>, <tt>fileIn</tt>,
--   <tt>fileOut</tt>. <tt>fileIn</tt> is encrypted based on <a>encrypt</a>
--   with <tt>keyFile</tt>, and the ciphertext is written to
--   <tt>fileOut</tt>.
encryptIO :: String -> String -> String -> IO ()

-- | Takes 3 <a>String</a>s, <tt>keyFile</tt>, <tt>fileIn</tt>,
--   <tt>fileOut</tt>. <tt>fileIn</tt> is decrypted based on <a>decrypt</a>
--   with <tt>keyFile</tt>, and the decrypted text is written to
--   <tt>fileOut</tt>.
decryptIO :: String -> String -> String -> IO ()

-- | Takes a <a>RandomGen</a> <tt>g</tt>, <a>Integral</a> <tt>size</tt>. If
--   is <tt>size</tt> one of 1024, 2048, or 4096 then returns <a>Just</a>
--   (<a>ByteString</a>, <a>ByteString</a>), where the <a>ByteString</a>s
--   are the public and private keys, respectively. If <tt>size</tt> is
--   anything then <a>Nothing</a> is returned.
keygen :: (RandomGen a, Integral b) => a -> b -> Maybe (ByteString, ByteString)

-- | Takes a <a>RandomGen</a> g and two <a>ByteString</a>s <tt>k</tt>,
--   <tt>m</tt>, representing the <tt>key</tt> and <tt>message</tt> to be
--   encrypted. <tt>m</tt> is encrypted with AES-256 in ECB mode (I know)
--   to produce ciphertext <tt>c</tt>. The generated AES key <tt>l</tt> is
--   then encrypted with the public key <tt>k</tt>, so the final output is
--   <tt>RSA_k(l)|AES_l(m)</tt>.
encrypt :: (RandomGen a) => a -> ByteString -> ByteString -> ByteString

-- | Takes two <a>ByteString</a>s <tt>k</tt>, <tt>m</tt>, representing the
--   <tt>key</tt> and <tt>ciphertext</tt> to be decrypted.
decrypt :: ByteString -> ByteString -> ByteString
